"use strict";
var _ = require("lodash");
/** Contains a set of model definitions.
 * Model templates are designed around server-side object property names and values
 * being formatted differently than local model property names and values.
 * Each model contains a list of properties with meta-attributes defining data-type,
 * default value, and source code template expressions for converting properties to and from service objects.
 * @author Benjamin
 * @since 2015-1-6
 */
var DefaultModelDefinitions = (function () {
    // generate model information the first time this JS module loads
    function DefaultModelDefinitions(dataModels, dataTypes) {
        this.dataTypes = dataTypes;
        this.models = dataModels;
        this.generateAdditionalModelsInfo(dataModels);
    }
    // creates maps of model names to primary key property and auto-generate property names
    DefaultModelDefinitions.prototype.generateAdditionalModelsInfo = function (dataModels) {
        this.modelDefs = {};
        var modelNames = Object.keys(dataModels);
        for (var i = 0, size = modelNames.length; i < size; i++) {
            var modelName = modelNames[i];
            var table = dataModels[modelName];
            var tableProps = table.properties;
            // setup mapping of model names to collection names and vice versa
            var primaryKeys = [];
            var autoGeneratedKeys = [];
            var fieldNames = Object.keys(tableProps);
            for (var ii = 0, sizeI = fieldNames.length; ii < sizeI; ii++) {
                var propName = fieldNames[ii];
                var propVal = tableProps[propName];
                if (propVal.primaryKey === true) {
                    primaryKeys.push(propName);
                    // an auto-generated property must be a primary key as well
                    if (propVal.autoGenerate === true) {
                        autoGeneratedKeys.push(propName);
                    }
                }
            }
            this.modelDefs[modelName] = {
                fieldNames: fieldNames,
                primaryKeys: primaryKeys,
                autoGeneratedKeys: autoGeneratedKeys,
                copyFunc: table.copyFunc,
            };
        }
    };
    /* planning to implement in future
    function checkModelName(modelName) {
        if(modelDefsByName[modelName] == null) {
            throw new Error("unknown model name: " + modelName);
        }
    }

    function addModel(modelName, modelInfo) {
        if(modelDefsByName[modelName] != null) {
            throw new Error("model named '" + modelName + "' already exists, cannot add new model by that name");
        }
        modelDefsByName[modelName] = modelInfo;
        generateAdditionalModelsInfo();
    }
    */
    /** Get names of primary key properties of a model
     * @param {string} modelName: the name of the model
     * @return {string[]} an array of primary key names in the specified model,
     * or an empty string if the {@code modelName} is not recognized
     */
    DefaultModelDefinitions.prototype.getPrimaryKeyNames = function (modelName) {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.primaryKeys || DefaultModelDefinitions.EMPTY_ARRAY;
    };
    /** Get names of auto-generated properties of a model
     * @param {string} modelName: the name of the model
     * @return {string[]} an array of auto-generated property names in the
     * specified model, or an empty string if the {@code modelName} is not recognized
     */
    DefaultModelDefinitions.prototype.getAutoGeneratedKeyNames = function (modelName) {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.autoGeneratedKeys || DefaultModelDefinitions.EMPTY_ARRAY;
    };
    DefaultModelDefinitions.prototype.getFieldNames = function (modelName) {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.fieldNames || DefaultModelDefinitions.EMPTY_ARRAY;
    };
    DefaultModelDefinitions.prototype.getCopyFunc = function (modelName) {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.copyFunc || null;
    };
    DefaultModelDefinitions.prototype.getDataModel = function (modelName) {
        return this.modelDefs[modelName];
    };
    DefaultModelDefinitions.EMPTY_ARRAY = Object.freeze([]);
    return DefaultModelDefinitions;
})();
var DefaultModelDefinitions;
(function (DefaultModelDefinitions) {
    function extendModelDef(parent, child) {
        var res = _.cloneDeep(parent);
        for (var childProp in child) {
            res[childProp] = _.clone(child[childProp]);
        }
        return res;
    }
    DefaultModelDefinitions.extendModelDef = extendModelDef;
    /** the last argument is the child class, each previous argument is the parent that the child will extend.
     * equivalent to {@code extendModelDef(inheritanceChain[0], extendModelDef(inheritanceChain[1], extendModelDef(...)))}
     * @return {StringMap<ServiceProperty>} the original child class (last argument) extended by all other arguments
     */
    function multiExtendModelDef() {
        var inheritanceChain = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            inheritanceChain[_i - 0] = arguments[_i];
        }
        var childClass = inheritanceChain[inheritanceChain.length - 1];
        for (var i = inheritanceChain.length - 2; i > -1; i--) {
            childClass = DefaultModelDefinitions.extendModelDef(inheritanceChain[i], childClass);
        }
        return childClass;
    }
    DefaultModelDefinitions.multiExtendModelDef = multiExtendModelDef;
})(DefaultModelDefinitions || (DefaultModelDefinitions = {}));
module.exports = DefaultModelDefinitions;
