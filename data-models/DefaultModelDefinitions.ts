"use strict";
import _ = require("lodash");

/** Contains a set of model definitions.
 * Model templates are designed around server-side object property names and values
 * being formatted differently than local model property names and values.
 * Each model contains a list of properties with meta-attributes defining data-type,
 * default value, and source code template expressions for converting properties to and from service objects.
 * @author Benjamin
 * @since 2015-1-6
 */
class DefaultModelDefinitions implements ModelDefinitions {
    private static EMPTY_ARRAY = Object.freeze([]);

    public dataTypes: { [id: string]: { value: any; toService?: string; toLocal?: string } };
    public models: { [id: string]: WebServiceModelDef | CollectionModelDef<any> };
    private modelDefs: { [id: string]: CollectionDataModel<any> };


    // generate model information the first time this JS module loads
    constructor(dataModels: { [id: string]: WebServiceModelDef | CollectionModelDef<any> }, dataTypes: { [id: string]: { value: any; toService: any; } }) {
        this.dataTypes = dataTypes;
        this.models = dataModels;
        this.generateAdditionalModelsInfo(dataModels);
    }


    // creates maps of model names to primary key property and auto-generate property names
    private generateAdditionalModelsInfo(dataModels: { [id: string]: WebServiceModelDef | CollectionModelDef<any> }) {
        this.modelDefs = {};

        var modelNames = Object.keys(dataModels);
        for (var i = 0, size = modelNames.length; i < size; i++) {
            var modelName = modelNames[i];
            var table = dataModels[modelName];
            var tableProps = table.properties;

            // setup mapping of model names to collection names and vice versa
            var primaryKeys: string[] = [];
            var autoGeneratedKeys: string[] = [];

            var fieldNames = Object.keys(tableProps);
            for (var ii = 0, sizeI = fieldNames.length; ii < sizeI; ii++) {
                var propName = fieldNames[ii];
                var propVal = tableProps[propName];
                if (propVal.primaryKey === true) {
                    primaryKeys.push(propName);
                    // an auto-generated property must be a primary key as well
                    if (propVal.autoGenerate === true) {
                        autoGeneratedKeys.push(propName);
                    }
                }
            }

            this.modelDefs[modelName] = {
                fieldNames,
                primaryKeys,
                autoGeneratedKeys,
                copyFunc: (<CollectionModelDef<any>>table).copyFunc,
            };
        }
    }


    /* planning to implement in future
    function checkModelName(modelName) {
        if(modelDefsByName[modelName] == null) {
            throw new Error("unknown model name: " + modelName);
        }
    }

    function addModel(modelName, modelInfo) {
        if(modelDefsByName[modelName] != null) {
	        throw new Error("model named '" + modelName + "' already exists, cannot add new model by that name");
        }
	    modelDefsByName[modelName] = modelInfo;
        generateAdditionalModelsInfo();
    }
    */


    /** Get names of primary key properties of a model
     * @param {string} modelName: the name of the model
     * @return {string[]} an array of primary key names in the specified model,
     * or an empty string if the {@code modelName} is not recognized
     */
    public getPrimaryKeyNames(modelName: string): string[] {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.primaryKeys || DefaultModelDefinitions.EMPTY_ARRAY;
    }


    /** Get names of auto-generated properties of a model
     * @param {string} modelName: the name of the model
     * @return {string[]} an array of auto-generated property names in the
     * specified model, or an empty string if the {@code modelName} is not recognized
     */
    public getAutoGeneratedKeyNames(modelName: string): string[] {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.autoGeneratedKeys || DefaultModelDefinitions.EMPTY_ARRAY;
    }


    public getFieldNames(modelName: string): string[] {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.fieldNames || DefaultModelDefinitions.EMPTY_ARRAY;
    }


    public getCopyFunc(modelName: string): (obj: any) => any {
        var modelDef = this.modelDefs[modelName];
        return modelDef && modelDef.copyFunc || null;
    }


    public getDataModel(modelName: string): CollectionDataModel<any> {
        return this.modelDefs[modelName];
    }

}

module DefaultModelDefinitions {

    export function extendModelDef(parent: StringMap<ServiceProperty>, child: StringMap<ServiceProperty>): StringMap<ServiceProperty> {
        var res: StringMap<ServiceProperty> = _.cloneDeep(parent);
        for (var childProp in child) {
            res[childProp] = _.clone(child[childProp])
        }
        return res;
    }


    /** the last argument is the child class, each previous argument is the parent that the child will extend.
     * equivalent to {@code extendModelDef(inheritanceChain[0], extendModelDef(inheritanceChain[1], extendModelDef(...)))}
     * @return {StringMap<ServiceProperty>} the original child class (last argument) extended by all other arguments
     */
    export function multiExtendModelDef(...inheritanceChain: StringMap<ServiceProperty>[]): StringMap<ServiceProperty> {
        var childClass = inheritanceChain[inheritanceChain.length - 1];
        for (var i = inheritanceChain.length - 2; i > -1; i--) {
            childClass = DefaultModelDefinitions.extendModelDef(inheritanceChain[i], childClass);
        }
        return childClass;
    }

}

export = DefaultModelDefinitions;
