
/** Retrival/query functions for items in a collection
 * @since 2016-3-11
 */
interface DtoFuncs<E> {
    /** an optional function that copies a model, if none is provided, implementations should fall back on a default clone function */
    copyFunc: (obj: E) => E;
}



/** All functions retrival, querying, and conversion of items from a local collection to/from a server collection
 * @since 2016-3-11
 */
interface DtoAllFuncs<E, S> extends DtoFuncs<E> {
    /** Convert a server data model to a client data model */
    toLocalObject: (item: S) => E;
    /** Convert a client data model to a server data model */
    toSvcObject: (item: E) => S;
}



/** A DataCollection containing syncable DTOs
 * @template E the type of data stored in this collection
 * @template K the primary keys/required fields, this is a sub-set of required fields from type 'E'
 * @template S the server data type stored in this collection
 */
interface DtoCollection<E extends K, K, S> extends DataCollection<E, K> {
    /** Get data model helper functions associated with this collection/data model */
    getDataModelFuncs(): DtoAllFuncs<E, S>;
}



/** Represents meta-data about the items in a collection
 * @since 2015-12-15
 */
interface DataCollectionModel<E> {
    /** all the top level property names of the model */
    fieldNames: (keyof E & string)[];
    /** the names of all the properties which together uniquely represent each model instance */
    primaryKeys: (keyof E & string)[];
    /** the names of the properties which are auto generated (i.e. auto-increment ID keys) */
    autoGeneratedKeys: (keyof E & string)[];
}



/** ModelDefinitions - defines a set of data model meta-definitions
 */
interface ModelDefinitions {
    /** model names in the order they should be read/generated */
    modelNames: string[];

    /** Add a data model to this set of definitions, the data model is split into two pieces:
     * a model (containing the properties)
     * and a set of functions for working with that model (functions for copying, converting to/from service DTOs, etc.)
     */
    addModel<U, W>(modelName: string, model: DtoModel, modelFuncs?: DtoFuncs<U> | DtoAllFuncs<U, W>): { modelDef: DataCollectionModel<U>, modelFuncs: DtoAllFuncs<U, W> };

    getPrimaryKeys(modelName: string): string[];

    getAutoGeneratedKeys(modelName: string): string[];

    getFields(modelName: string): string[];

    getModel(modelName: string): DataCollectionModel<any>;

    getCopyFunc(modelName: string): (obj: any) => any;

    /** May return null if the model has no associated functions
     */
    getDataModelFuncs(modelName: string): DtoAllFuncs<any, any>;
}



/** ModelKeys - helper for ModelDefinitions
 * For managing the primary and auto-generated keys from data models
 */
interface ModelKeys {

    /** add missing IDs that should be auto-generated
     * @param autoGenKeys: in the format { name: "...", largestKey: 45678 }
     */
    addGeneratedIds(autoGenKeys: { name: string; largestKey: number }[], doc: any): void;

    /** track auto-generated IDs
     * @param autoGenKeys: in the format { name: "...", largestKey: 45678 }
     */
    trackGeneratedIds(autoGenKeys: { name: string; largestKey: number }[], doc: any): void;

    /** Given a query object, check its validity based on these constraints
     */
    validateQuery(collectionName: string, query: any, obj: any): any;


    /** Constrains the value of a field
     */
    //interface Constraint {
    //    public static NON_NULL: Constraint;
    //    public static UNIQUE: Constraint;
    //}


    /** How to handle auto generated fields (i.e. primary keys)
     */
    //interface Generated {
    //    public static AUTO_GENERATE: Generated;
    //    public static PRESERVE_EXISTING: Generated;
    //
    //}
}
